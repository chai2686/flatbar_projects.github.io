<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Voice Input with Wake Lock</title>
  <style>
    body {
      font-family: sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      //height: 100vh;
      padding: 20px;
      background-color: #f0f0f0;
    }
    input[type="text"] {
      width: 80%;
      padding: 15px;
      font-size: 1.2rem;
    }
    button {
      margin-top: 15px;
      padding: 10px 20px;
      font-size: 1rem;
    }
  </style>
</head>
<body>

  <h2>Speak to Enter Text</h2>
  <input type="text" id="textInput" placeholder="Speak something..." />
  <button id="micButton">üé§ Start Voice Input</button>
  <input style="margin-top: 15px;" type="text" id="thicktext" placeholder="thick..." />
  <input style="margin-top: 15px;" type="text" id="widthtext" placeholder="width..." />
  <input style="margin-top: 15px;" type="text" id="lengthtext" placeholder="length..." />
  <input style="margin-top: 15px;" type="text" id="quantitytext" placeholder="quantity..." />
  <input style="margin-top: 15px;" type="text" id="weighttext" placeholder="weight..." />

  <script>
  const micButton = document.getElementById('micButton');
  const textInput = document.getElementById('textInput');

  let recognition;
  let isListening = false;

  if ('webkitSpeechRecognition' in window) {
    recognition = new webkitSpeechRecognition();
	grammarlist = new webkitSpeechGrammarList();
	
	const grammarsize = '#JSGF V1.0; grammar size; public <size> = ‡∏°‡∏¥‡∏• | min | ‡∏´‡∏ô‡πâ‡∏≤ | ‡∏¢‡∏≤‡∏ß | ‡∏Ñ‡∏ß‡∏≤‡∏°‡∏¢‡∏≤‡∏ß | ‡πÑ‡∏ã‡∏™‡πå | size | ‡∏°‡∏° | ‡∏Å‡∏¥‡πÇ‡∏• ;';
	grammarlist.addFromString(grammarsize, 1.0);
	recognition.grammars = grammarlist;
	
    //recognition.lang = 'en-US';
	recognition.lang = 'th-TH';
    recognition.continuous = true; // <-- long dictation
    recognition.interimResults = false;

    recognition.onresult = function(event) {
      let transcript = '';
      for (let i = event.resultIndex; i < event.results.length; ++i) {
        transcript += event.results[i][0].transcript;
      }
      textInput.value += transcript + ' ';
    };

    recognition.onerror = function(event) {
      console.error('Speech recognition error:', event.error);
      if (event.error === 'no-speech' || event.error === 'audio-capture') {
        stopListening();
      }
    };

    recognition.onend = function() {
      if (isListening) {
        recognition.start(); // restart if still active
      }
    };
  } else {
    alert("Your browser doesn't support Speech Recognition.");
  }

  function startListening() {
    isListening = true;
    recognition.start();
    micButton.textContent = 'üõë Stop Voice Input';
  }

  function stopListening() {
    isListening = false;
    recognition.stop();
    micButton.textContent = 'üé§ Start Voice Input';
	splitText();
  }

  micButton.addEventListener('click', () => {
    if (!isListening) {
      startListening();
    } else {
      stopListening();
    }
  });

  // Wake Lock API
  let wakeLock = null;

  async function requestWakeLock() {
    try {
      if ('wakeLock' in navigator) {
        wakeLock = await navigator.wakeLock.request('screen');
        //console.log('Wake Lock is active');

        wakeLock.addEventListener('release', () => {
          //console.log('Wake Lock released');
        });
      } else {
        console.warn('Wake Lock API not supported.');
      }
    } catch (err) {
      console.error(`${err.name}, ${err.message}`);
    }
  }

  document.addEventListener('visibilitychange', () => {
    if (wakeLock !== null && document.visibilityState === 'visible') {
      requestWakeLock();
    }
  });

  requestWakeLock();
  
  function splitText() {
    const input = document.getElementById('textInput').value.trim();
    const words = input.split(/\s+/); // split by one or more spaces
    const thicktext = document.getElementById('thicktext');
	const widthtext = document.getElementById('widthtext');
	const lengthtext = document.getElementById('lengthtext');

    const thicknessKeywords = ["min", "‡∏°‡∏¥‡∏•", "‡∏°‡∏¥‡∏•‡∏´‡∏ô‡πâ‡∏≤", "‡∏°‡∏°", "‡∏°‡∏°‡∏´‡∏ô‡πâ‡∏≤"];
    let hasThickness = false;
    for (const keyword of thicknessKeywords) {
        const index = words.findIndex(word => word.toLowerCase() === keyword.toLowerCase());
        if (index > 0) {
            thicktext.value = words[index - 1]; // Get the word before the keyword
            hasThickness = true;
            console.log("‡∏û‡∏ö‡∏Ñ‡∏ß‡∏≤‡∏°‡∏´‡∏ô‡∏≤:", keyword, "=>", words[index - 1]);
            break;
        }
    }

    if (!hasThickness) {
        console.log("‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ñ‡∏ß‡∏≤‡∏°‡∏´‡∏ô‡∏≤");
    }
	
	const widthKeywords = ["‡∏°‡∏¥‡∏•‡∏´‡∏ô‡πâ‡∏≤", "‡∏´‡∏ô‡πâ‡∏≤", "‡∏°‡∏°‡∏´‡∏ô‡πâ‡∏≤"];
    let haswidth = false;
    for (const keyword of widthKeywords) {
        const index = words.findIndex(word => word.toLowerCase() === keyword.toLowerCase());
        if (index > 0) {
            widthtext.value = words[index + 1]; // Get the word before the keyword
            haswidth = true;
            console.log("‡∏û‡∏ö‡∏´‡∏ô‡πâ‡∏≤‡∏Å‡∏ß‡πâ‡∏≤‡∏á:", keyword, "=>", words[index + 1]);
            break;
        }
    }

    if (!haswidth) {
        console.log("‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏´‡∏ô‡πâ‡∏≤‡∏Å‡∏ß‡πâ‡∏≤‡∏á");
    }
	
	const lengthKeywords = ["‡∏¢‡∏≤‡∏ß", "‡∏Ñ‡∏ß‡∏≤‡∏°‡∏¢‡∏≤‡∏ß"];
    let haslength = false;
    for (const keyword of lengthKeywords) {
        const index = words.findIndex(word => word.toLowerCase() === keyword.toLowerCase());
        if (index > 0) {
            lengthtext.value = words[index + 1]; // Get the word before the keyword
            haslength = true;
            console.log("‡∏û‡∏ö‡∏Ñ‡∏ß‡∏≤‡∏°‡∏¢‡∏≤‡∏ß:", keyword, "=>", words[index + 1]);
            break;
        }
    }

    if (!haslength) {
		lengthtext.value = 6000;
        console.log("‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ñ‡∏ß‡∏≤‡∏°‡∏¢‡∏≤‡∏ß");
    }
	
	const quantityKeywords = ["‡∏à‡∏≥‡∏ô‡∏ß‡∏ô"];
    let hasquantity = false;
    for (const keyword of quantityKeywords) {
        const index = words.findIndex(word => word.toLowerCase() === keyword.toLowerCase());
        if (index > 0) {
            quantitytext.value = words[index + 1]; // Get the word before the keyword
            hasquantity = true;
            console.log("‡∏û‡∏ö‡∏à‡∏≥‡∏ô‡∏ß‡∏ô:", keyword, "=>", words[index + 1]);
            break;
        }
    }
	
	const needKeywords = ["‡πÄ‡∏≠‡∏≤"];
    for (const keyword of needKeywords) {
        const index = words.findIndex(word => word.toLowerCase() === keyword.toLowerCase());
        if (index > 0) {
            quantitytext.value = words[index + 1]; // Get the word before the keyword
            hasquantity = true;
            console.log("‡∏û‡∏ö‡∏à‡∏≥‡∏ô‡∏ß‡∏ô:", keyword, "=>", words[index + 1]);
            break;
        }
    }

    if (!hasquantity) {
        console.log("‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏à‡∏≥‡∏ô‡∏ß‡∏ô");
    }
	
	const hasWeight = words.includes("‡∏ô‡πâ‡∏≥‡∏´‡∏ô‡∏±‡∏Å");
	const hasKG = words.includes("‡∏Å‡∏¥‡πÇ‡∏•");
	if (hasWeight && hasKG) {
    console.log("‡∏û‡∏ö‡∏ô‡πâ‡∏≥‡∏´‡∏ô‡∏±‡∏Å");

    const input = document.getElementById('textInput').value;

    // Step 1: Extract text from "‡∏ô‡πâ‡∏≥‡∏´‡∏ô‡∏±‡∏Å" to "‡∏Å‡∏¥‡πÇ‡∏•"
    const match = input.match(/‡∏ô‡πâ‡∏≥‡∏´‡∏ô‡∏±‡∏Å(.*?)‡∏Å‡∏¥‡πÇ‡∏•/);

		if (match && match[1]) {
			const mathText = match[1].trim(); // e.g., "352 + 675 - 300"

			// Step 2: Clean the math expression to keep only digits and math symbols
			const cleanExpr = mathText.replace(/[^0-9+\-*/.]/g, '');

			try {
				const sum = eval(cleanExpr); // e.g., eval("352+675-300")
				weighttext.value = sum;
				console.log("‡∏£‡∏ß‡∏°:", sum);
			} catch (err) {
				console.error("‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡πÑ‡∏î‡πâ:", err);
			}
		} else {
			console.log("‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö‡∏ô‡πâ‡∏≥‡∏´‡∏ô‡∏±‡∏Å‡∏ó‡∏µ‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á");
		}
	}
	
}
	
</script>

</body>
</html>
